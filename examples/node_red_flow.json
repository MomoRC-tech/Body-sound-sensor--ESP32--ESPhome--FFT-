[
  {
    "id": "a1b2c3d4e5f6g7h8",
    "type": "tab",
    "label": "Body Sound Pipeline",
    "disabled": false,
    "info": "Flow: ESPHome body sound spectrum -> parse -> InfluxDB. Replace entity IDs with your actual Home Assistant entity names before deploying."
  },
  {
    "id": "srv-ha-01",
    "type": "server",
    "name": "Home Assistant",
    "addon": false
  },
  {
    "id": "srv-influx-01",
    "type": "influxdb",
    "hostname": "influxdb",
    "port": "8086",
    "protocol": "http",
    "database": "sensors",
    "name": "InfluxDB",
    "usetls": false,
    "tls": "",
    "influxdbVersion": "1.x",
    "url": "",
    "rejectUnauthorized": true
  },
  {
    "id": "evt-spectrum",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "Spectrum JSON state",
    "server": "srv-ha-01",
    "version": 3,
    "exposeToHomeAssistant": false,
    "haConfig": [],
    "entityidfilter": "sensor.body_sound_spectrum_json",
    "entityidfiltertype": "exact",
    "outputinitially": false,
    "state_type": "str",
    "halt_if":"",
    "halt_if_type":"str",
    "halt_if_compare":"is",
    "output_only_on_state_change": true,
    "for": "",
    "forType": "num",
    "forUnits": "minutes",
    "ignorePrevStateNull": true,
    "ignorePrevStateUnknown": true,
    "ignorePrevStateUnavailable": true,
    "ignoreCurrentStateUnknown": true,
    "ignoreCurrentStateUnavailable": true,
    "x": 190,
    "y": 120,
    "wires": [["switch-spectrum"]]
  },
  {
    "id": "evt-cpu",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "CPU load state",
    "server": "srv-ha-01",
    "version": 3,
    "exposeToHomeAssistant": false,
    "haConfig": [],
    "entityidfilter": "sensor.body_sound_fft_cpu_load",
    "entityidfiltertype": "exact",
    "outputinitially": true,
    "state_type": "num",
    "halt_if":"",
    "halt_if_type":"str",
    "halt_if_compare":"is",
    "output_only_on_state_change": true,
    "x": 190,
    "y": 200,
    "wires": [["fn-cpu-cache"]]
  },
  {
    "id": "switch-spectrum",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "Valid spectrum state?",
    "property": "data.new_state.state",
    "propertyType": "msg",
    "rules": [
      {"t":"nempty"},
      {"t":"neq","v":"unknown","vt":"str"},
      {"t":"neq","v":"unavailable","vt":"str"}
    ],
    "checkall": "true",
    "repair": false,
    "outputs": 1,
    "x": 430,
    "y": 120,
    "wires": [["fn-parse-spectrum"]]
  },
  {
    "id": "fn-cpu-cache",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "Cache latest CPU load",
    "func": "// Store latest CPU load in flow context for enrichment when spectrum arrives\nconst val = Number(msg.data.new_state.state || 0);\nflow.set('cpu_load_latest', val);\nreturn null;",
    "outputs": 0,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 440,
    "y": 200,
    "wires": []
  },
  {
    "id": "fn-parse-spectrum",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "Parse + Build Influx point",
    "func": "// Parse JSON spectrum, enrich with cached CPU load, output InfluxDB payload\nconst raw = msg.data.new_state.state;\nlet j;\ntry {\n  j = JSON.parse(raw);\n} catch (e) {\n  node.error('Spectrum JSON parse failed: ' + e.message, msg);\n  return null;\n}\n// Schema version gating\nif (j.schema_version && j.schema_version > 1) {\n  node.warn(`Future schema_version ${j.schema_version} > supported 1`);\n}\nconst fields = {};\nif (Array.isArray(j.bands)) {\n  j.bands.forEach((val, idx) => { fields['band_' + idx] = Number(val); });\n}\nfields.rms = Number(j.rms || 0);\nfields.peak_hz = Number(j.peak_hz || 0);\nfields.fs = Number(j.fs || 0);\nfields.fft_size = Number(j.n || 0);\nfields.max_analysis_hz = Number(j.max_analysis_hz || 0);\nfields.bin_hz = Number(j.bin_hz || 0);\nfields.ts_ms = Number(j.ts_ms || 0);\nfields.win_ms = Number(j.win_ms || 0);\nfields.hop_ms = Number(j.hop_ms || 0);\nfields.seq = Number(j.seq || 0);\nif (j.epoch_ms) fields.epoch_ms = Number(j.epoch_ms);\nconst cpu_cached = flow.get('cpu_load_latest');\nif (typeof cpu_cached !== 'undefined') fields.cpu_load = cpu_cached;\nmsg.payload = [{\n  measurement: 'body_sound',\n  fields,\n  tags: { sensor: 'body_sound_1', location: 'basement' }\n}];\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 690,
    "y": 120,
    "wires": [["fn-derived2"]]
  },
  {
    "id": "fn-derived2",
    "z": "a1b2c3d4e5f6g7h8",
    "name": "Derived features (max & centroid)",
    "func": "// Compute max band energy and spectral centroid from existing fields\n// Assumptions: fields contain band_0..band_N and max_analysis_hz.\n// Centroid approximation: sum(f_i * E_i) / sum(E_i) where f_i = (i + 0.5) * (max_analysis_hz / bandCount).\nif (!Array.isArray(msg.payload) || !msg.payload[0] || !msg.payload[0].fields) { return null; }\nconst rec = msg.payload[0];\nconst fields = rec.fields;\nconst bandKeys = Object.keys(fields).filter(k => /^band_\\d+$/.test(k));\nif (bandKeys.length === 0) { return msg; }\nconst energies = bandKeys.map(k => Number(fields[k]));\nlet maxEnergy = -Infinity;\nlet maxIndex = -1;\nenergies.forEach((e,i)=>{ if (e > maxEnergy) { maxEnergy = e; maxIndex = i; } });\nconst bandCount = energies.length;\nconst maxHz = Number(fields.max_analysis_hz || 0);\nlet sumE = 0;\nlet weighted = 0;\nfor (let i=0;i<bandCount;i++){ const e = energies[i]; sumE += e; const fCenter = (i + 0.5) * (maxHz / bandCount); weighted += fCenter * e; }\nfields.max_band_energy = maxEnergy;\nfields.max_band_index = maxIndex;\nfields.spectral_centroid_hz = sumE > 0 ? (weighted / sumE) : 0;\nreturn msg;",
    "outputs": 1,
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 900,
    "y": 180,
    "wires": [["influx-out"]]
  },
  {
    "id": "influx-out",
    "z": "a1b2c3d4e5f6g7h8",
    "influxdb": "srv-influx-01",
    "name": "InfluxDB write",
    "measurement": "",
    "precision": "",
    "retentionPolicy": "",
    "x": 930,
    "y": 120,
    "wires": []
  },
  {
    "id": "comment-entities",
    "z": "a1b2c3d4e5f6g7h8",
    "type": "comment",
    "name": "Replace entity IDs if different",
    "info": "Ensure the entity IDs match Home Assistant (use Developer Tools > States). Typical names:\n- sensor.body_sound_fft_cpu_load\n- sensor.body_sound_spectrum_json\nIf your text sensor domain differs (e.g., text_sensor.body_sound_spectrum_json), adjust entityidfilter accordingly.",
    "x": 250,
    "y": 60,
    "wires": []
  },
  {
    "id": "comment-tags",
    "z": "a1b2c3d4e5f6g7h8",
    "type": "comment",
    "name": "Adjust tags + measurement",
    "info": "Change measurement name from body_sound if desired; update tags for multi-sensor deployments (e.g., sensor: body_sound_pump_1).",
    "x": 950,
    "y": 60,
    "wires": []
  }
]
